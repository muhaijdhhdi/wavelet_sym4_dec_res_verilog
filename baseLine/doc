## baseLine
* **decompose_L1-L7.v**：sym4 小波分解模块
* **restruct_L7-L1.v**：sym4 小波重构模块

#### 模块延迟分析
* **物理延迟**：始终为 3 个时钟周期。
* **输入起点**：从第 0 个周期开始输入数据 + `valid_in`。

| Level | T (输出有效时刻) | 算法延迟 (缓存上一级的周期) |
| :--- | :--- | :--- |
| x | 0 | x + valid_in |
| L1 | 4 | 1 |
| L2 | 8 | 1 |
| L3 | 13 | 2 |
| L4 | 20 | 4 |
| L5 | 30 | 7 |
| L6 | 47 | 14 |
| L7 | 78 | 28 |

**延迟逻辑说明：**
* 第一个时钟周期数据流进去（16ch），需要等到第 79 个周期才有对应的数据输出来。
* 模块中每一级均引入了 `has_data` 变量进行处理，用以考虑算法延迟。
* **物理延迟永远为 3**：即一个数据进来到出去物理耗时 3 个时钟周期，但此时输出的数据并非该输入数据对应的计算结果。
* **总延迟计算**：每一级的延迟 = 算法延迟 + 物理延迟。
* **算法延迟来源**：
    * 第 1 级：缓存上一级的 1 个周期数。
    * 第 2 级：缓存 L1 的 1 个周期。
    * 第 3 级：缓存 L2 的 2 个周期。
    * 第 4 级：缓存 L3 的 4 个周期。
    * 第 5 级：缓存 L4 的 7 个周期。
    * 第 6 级：缓存 14 个周期。
    * 第 7 级：缓存 28 个周期。
    * 整体延迟 1+1+2+4+7+14+28+3*7=78

---

### script
* **验证精度**：小波分解模块验证精度较高，约为 130dB。
* **a1x_error_analysis.py**：从第一级分解模块到第 x 级分解模块的级联误差验证脚本。数据产生方式与 `x_gen.py` 一致。通过对 L1-L7 进行建模，验证延迟和计算精度，比对 Python 黄金模型与 Verilog 硬件输出。
* **tb_decompose_L1n**：L1 到 Ln 的级联模块 Verilog 仿真平台。结果写入 `a1-a7output.txt`，供误差分析脚本使用。

---

### 验证步骤
1. **运行 x_gen.py**：产生原始输入数据。
2. **运行 tb_decompose_Ln**：进行仿真，并将输出数据存储到 `a1_output.txt` ... `a7_output.txt` 中。
3. **运行 a17_error_analysis.py**：执行 Python 模型计算，读取硬件数据，并计算 L7 端的误差。
4. **参数同步**：可以改变数据参数，但必须确保两个 `.py` 文件中的配置数据保持一致。